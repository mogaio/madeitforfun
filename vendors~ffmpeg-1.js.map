{"version":3,"sources":["webpack:///./node_modules/resolve-url/resolve-url.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/utils/log.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/utils/getId.js","webpack:///./node_modules/regenerator-runtime/runtime.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/createWorker.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/createJob.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/utils/extractProgress.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/utils/resolvePaths.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/utils/getEnvironment.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/worker/browser/index.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/worker/browser/defaultOptions.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/constants/defaultOptions.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/worker/browser/spawnWorker.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/worker/browser/terminateWorker.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/worker/browser/onMessage.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/worker/browser/send.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/worker/browser/fetchFile.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/worker/browser/fs.js","webpack:///./node_modules/idb/build/esm/chunk.js","webpack:///./node_modules/idb/build/esm/index.js","webpack:///./node_modules/@ffmpeg/ffmpeg/src/index.js"],"names":["numUrls","arguments","length","Error","base","document","createElement","href","head","getElementsByTagName","insertBefore","firstChild","resolved","a","index","removeChild","logging","exports","setLogging","_logging","log","args","console","apply","this","module","prefix","cnt","Math","random","toString","slice","runtime","Op","Object","prototype","hasOwn","hasOwnProperty","$Symbol","Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","_invoke","state","method","arg","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","abrupt","record","tryCatch","type","done","value","makeInvokeMethod","fn","obj","call","err","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","AsyncIterator","previousPromise","callInvokeWithMethodAndArg","Promise","resolve","reject","invoke","result","__await","then","unwrapped","error","undefined","TypeError","info","resultName","next","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","push","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","i","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","awrap","async","iter","keys","object","key","reverse","pop","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","regeneratorRuntime","accidentalStrictMode","Function","createJob","getId","extractProgress","resolvePaths","defaultOptions","spawnWorker","terminateWorker","onMessage","send","fetchFile","fs","workerCounter","_options","id","logger","progress","options","resolves","rejects","worker","setResolve","action","res","setReject","rej","startJob","jobId","payload","workerId","syncfs","populate","writeText","path","text","writeFile","run","opts","status","data","d","_data","Uint8Array","from","load","write","read","del","readFile","deleteFile","remove","transcode","input","output","trim","to","concatDemuxer","reduce","acc","ls","terminate","jobCounter","_id","duration","ts2sec","ts","h","m","s","split","parseFloat","message","startsWith","ratio","resolveURL","env","window","version","dependencies","workerPath","process","FFMPEG_ENV","corePath","substring","workerBlobURL","Blob","URL","blob","Worker","createObjectURL","handler","onmessage","packet","postMessage","test","atob","map","c","charCodeAt","fetch","arrayBuffer","File","fileReader","FileReader","onload","onerror","target","code","readAsArrayBuffer","openDB","getDB","getDataKeyAndMode","db","dummy","get","dataKey","filter","k","includes","mode","put","timestamp","Date","delete","idbProxyableTypes","cursorAdvanceMethods","cursorRequestMap","WeakMap","transactionDoneMap","transactionStoreNamesMap","transformCache","reverseTransformCache","idbProxyTraps","prop","receiver","IDBTransaction","objectStoreNames","objectStore","has","wrapFunction","func","IDBDatabase","transaction","IDBCursor","advance","continue","continuePrimaryKey","unwrap","storeNames","tx","set","sort","transformCachableValue","unlisten","removeEventListener","addEventListener","cacheDonePromiseForTransaction","IDBObjectStore","IDBIndex","some","Proxy","IDBRequest","request","promise","success","catch","promisifyRequest","newValue","blocked","upgrade","blocking","indexedDB","open","openPromise","event","oldVersion","newVersion","deleteDB","deleteDatabase","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","storeName","store","shift","returnVal","oldTraps","callback","createWorker"],"mappings":"6EAAA,aAKkB,0BAAd,EAMI,WAiCN,OA/BA,WACE,IAAIA,EAAUC,UAAUC,OAExB,GAAgB,IAAZF,EACF,MAAM,IAAIG,MAAM,wDAGlB,IAAIC,EAAOC,SAASC,cAAc,QAGlC,GAFAF,EAAKG,KAAON,UAAU,GAEN,IAAZD,EACF,OAAOI,EAAKG,KAGd,IAAIC,EAAOH,SAASI,qBAAqB,QAAQ,GACjDD,EAAKE,aAAaN,EAAMI,EAAKG,YAK7B,IAHA,IACIC,EADAC,EAAIR,SAASC,cAAc,KAGtBQ,EAAQ,EAAGA,EAAQd,EAASc,IACnCD,EAAEN,KAAON,UAAUa,GACnBF,EAAWC,EAAEN,KACbH,EAAKG,KAAOK,EAKd,OAFAJ,EAAKO,YAAYX,GAEVQ,KApCO,mC,kBCLlB,IAAII,GAAU,EAEdC,EAAQD,QAAUA,EAElBC,EAAQC,WAAcC,IACpBH,EAAUG,GAGZF,EAAQG,IAAM,IAAIC,IAAUL,EAAUM,QAAQF,IAAIG,MAAMC,KAAMH,GAAQ,M,kBCRtEI,EAAOR,QAAU,CAACS,EAAQC,IAAQ,GAC7BD,KAAUC,KAAOC,KAAKC,SAASC,SAAS,IAAIC,MAAM,EAAG,M,oBCM1D,IAAIC,EAAW,SAAUf,GACvB,aAEA,IAAIgB,EAAKC,OAAOC,UACZC,EAASH,EAAGI,eAEZC,EAA4B,mBAAXC,OAAwBA,OAAS,GAClDC,EAAiBF,EAAQG,UAAY,aACrCC,EAAsBJ,EAAQK,eAAiB,kBAC/CC,EAAoBN,EAAQO,aAAe,gBAE/C,SAASC,EAAKC,EAASC,EAASC,EAAMC,GAEpC,IAAIC,EAAiBH,GAAWA,EAAQb,qBAAqBiB,EAAYJ,EAAUI,EAC/EC,EAAYnB,OAAOoB,OAAOH,EAAehB,WACzCoB,EAAU,IAAIC,EAAQN,GAAe,IAMzC,OAFAG,EAAUI,QAkMZ,SAA0BV,EAASE,EAAMM,GACvC,IAAIG,EA3KuB,iBA6K3B,OAAO,SAAgBC,EAAQC,GAC7B,GA5KoB,cA4KhBF,EACF,MAAM,IAAIvD,MAAM,gCAGlB,GA/KoB,cA+KhBuD,EAA6B,CAC/B,GAAe,UAAXC,EACF,MAAMC,EAKR,OAAOC,IAMT,IAHAN,EAAQI,OAASA,EACjBJ,EAAQK,IAAMA,IAED,CACX,IAAIE,EAAWP,EAAQO,SACvB,GAAIA,EAAU,CACZ,IAAIC,EAAiBC,EAAoBF,EAAUP,GACnD,GAAIQ,EAAgB,CAClB,GAAIA,IAAmBE,EAAkB,SACzC,OAAOF,GAIX,GAAuB,SAAnBR,EAAQI,OAGVJ,EAAQW,KAAOX,EAAQY,MAAQZ,EAAQK,SAElC,GAAuB,UAAnBL,EAAQI,OAAoB,CACrC,GA/MqB,mBA+MjBD,EAEF,MADAA,EA7Mc,YA8MRH,EAAQK,IAGhBL,EAAQa,kBAAkBb,EAAQK,SAEN,WAAnBL,EAAQI,QACjBJ,EAAQc,OAAO,SAAUd,EAAQK,KAGnCF,EAxNkB,YA0NlB,IAAIY,EAASC,EAASxB,EAASE,EAAMM,GACrC,GAAoB,WAAhBe,EAAOE,KAAmB,CAO5B,GAJAd,EAAQH,EAAQkB,KA7NA,YAFK,iBAmOjBH,EAAOV,MAAQK,EACjB,SAGF,MAAO,CACLS,MAAOJ,EAAOV,IACda,KAAMlB,EAAQkB,MAGS,UAAhBH,EAAOE,OAChBd,EA3OgB,YA8OhBH,EAAQI,OAAS,QACjBJ,EAAQK,IAAMU,EAAOV,OA1QPe,CAAiB5B,EAASE,EAAMM,GAE7CF,EAcT,SAASkB,EAASK,EAAIC,EAAKjB,GACzB,IACE,MAAO,CAAEY,KAAM,SAAUZ,IAAKgB,EAAGE,KAAKD,EAAKjB,IAC3C,MAAOmB,GACP,MAAO,CAAEP,KAAM,QAASZ,IAAKmB,IAhBjC9D,EAAQ6B,KAAOA,EAoBf,IAOImB,EAAmB,GAMvB,SAASb,KACT,SAAS4B,KACT,SAASC,KAIT,IAAIC,EAAoB,GACxBA,EAAkB1C,GAAkB,WAClC,OAAOhB,MAGT,IAAI2D,EAAWjD,OAAOkD,eAClBC,EAA0BF,GAAYA,EAASA,EAASG,EAAO,MAC/DD,GACAA,IAA4BpD,GAC5BG,EAAO0C,KAAKO,EAAyB7C,KAGvC0C,EAAoBG,GAGtB,IAAIE,EAAKN,EAA2B9C,UAClCiB,EAAUjB,UAAYD,OAAOoB,OAAO4B,GAQtC,SAASM,EAAsBrD,GAC7B,CAAC,OAAQ,QAAS,UAAUsD,SAAQ,SAAS9B,GAC3CxB,EAAUwB,GAAU,SAASC,GAC3B,OAAOpC,KAAKiC,QAAQE,EAAQC,OAoClC,SAAS8B,EAAcrC,GAgCrB,IAAIsC,EAgCJnE,KAAKiC,QA9BL,SAAiBE,EAAQC,GACvB,SAASgC,IACP,OAAO,IAAIC,SAAQ,SAASC,EAASC,IAnCzC,SAASC,EAAOrC,EAAQC,EAAKkC,EAASC,GACpC,IAAIzB,EAASC,EAASlB,EAAUM,GAASN,EAAWO,GACpD,GAAoB,UAAhBU,EAAOE,KAEJ,CACL,IAAIyB,EAAS3B,EAAOV,IAChBc,EAAQuB,EAAOvB,MACnB,OAAIA,GACiB,iBAAVA,GACPtC,EAAO0C,KAAKJ,EAAO,WACdmB,QAAQC,QAAQpB,EAAMwB,SAASC,MAAK,SAASzB,GAClDsB,EAAO,OAAQtB,EAAOoB,EAASC,MAC9B,SAAShB,GACViB,EAAO,QAASjB,EAAKe,EAASC,MAI3BF,QAAQC,QAAQpB,GAAOyB,MAAK,SAASC,GAI1CH,EAAOvB,MAAQ0B,EACfN,EAAQG,MACP,SAASI,GAGV,OAAOL,EAAO,QAASK,EAAOP,EAASC,MAvBzCA,EAAOzB,EAAOV,KAiCZoC,CAAOrC,EAAQC,EAAKkC,EAASC,MAIjC,OAAOJ,EAaLA,EAAkBA,EAAgBQ,KAChCP,EAGAA,GACEA,KA+GV,SAAS5B,EAAoBF,EAAUP,GACrC,IAAII,EAASG,EAASrB,SAASc,EAAQI,QACvC,QApSE2C,IAoSE3C,EAAsB,CAKxB,GAFAJ,EAAQO,SAAW,KAEI,UAAnBP,EAAQI,OAAoB,CAE9B,GAAIG,EAASrB,SAAiB,SAG5Bc,EAAQI,OAAS,SACjBJ,EAAQK,SA/SZ0C,EAgTItC,EAAoBF,EAAUP,GAEP,UAAnBA,EAAQI,QAGV,OAAOM,EAIXV,EAAQI,OAAS,QACjBJ,EAAQK,IAAM,IAAI2C,UAChB,kDAGJ,OAAOtC,EAGT,IAAIK,EAASC,EAASZ,EAAQG,EAASrB,SAAUc,EAAQK,KAEzD,GAAoB,UAAhBU,EAAOE,KAIT,OAHAjB,EAAQI,OAAS,QACjBJ,EAAQK,IAAMU,EAAOV,IACrBL,EAAQO,SAAW,KACZG,EAGT,IAAIuC,EAAOlC,EAAOV,IAElB,OAAM4C,EAOFA,EAAK/B,MAGPlB,EAAQO,EAAS2C,YAAcD,EAAK9B,MAGpCnB,EAAQmD,KAAO5C,EAAS6C,QAQD,WAAnBpD,EAAQI,SACVJ,EAAQI,OAAS,OACjBJ,EAAQK,SAnWV0C,GA6WF/C,EAAQO,SAAW,KACZG,GANEuC,GA3BPjD,EAAQI,OAAS,QACjBJ,EAAQK,IAAM,IAAI2C,UAAU,oCAC5BhD,EAAQO,SAAW,KACZG,GAoDX,SAAS2C,EAAaC,GACpB,IAAIC,EAAQ,CAAEC,OAAQF,EAAK,IAEvB,KAAKA,IACPC,EAAME,SAAWH,EAAK,IAGpB,KAAKA,IACPC,EAAMG,WAAaJ,EAAK,GACxBC,EAAMI,SAAWL,EAAK,IAGxBrF,KAAK2F,WAAWC,KAAKN,GAGvB,SAASO,EAAcP,GACrB,IAAIxC,EAASwC,EAAMQ,YAAc,GACjChD,EAAOE,KAAO,gBACPF,EAAOV,IACdkD,EAAMQ,WAAahD,EAGrB,SAASd,EAAQN,GAIf1B,KAAK2F,WAAa,CAAC,CAAEJ,OAAQ,SAC7B7D,EAAYuC,QAAQmB,EAAcpF,MAClCA,KAAK+F,OAAM,GA8Bb,SAASjC,EAAOkC,GACd,GAAIA,EAAU,CACZ,IAAIC,EAAiBD,EAAShF,GAC9B,GAAIiF,EACF,OAAOA,EAAe3C,KAAK0C,GAG7B,GAA6B,mBAAlBA,EAASd,KAClB,OAAOc,EAGT,IAAKE,MAAMF,EAAStH,QAAS,CAC3B,IAAIyH,GAAK,EAAGjB,EAAO,SAASA,IAC1B,OAASiB,EAAIH,EAAStH,QACpB,GAAIkC,EAAO0C,KAAK0C,EAAUG,GAGxB,OAFAjB,EAAKhC,MAAQ8C,EAASG,GACtBjB,EAAKjC,MAAO,EACLiC,EAOX,OAHAA,EAAKhC,WAndT4B,EAodII,EAAKjC,MAAO,EAELiC,GAGT,OAAOA,EAAKA,KAAOA,GAKvB,MAAO,CAAEA,KAAM7C,GAIjB,SAASA,IACP,MAAO,CAAEa,WAneP4B,EAmeyB7B,MAAM,GA+MnC,OAxmBAO,EAAkB7C,UAAYoD,EAAGqC,YAAc3C,EAC/CA,EAA2B2C,YAAc5C,EACzCC,EAA2BrC,GACzBoC,EAAkB6C,YAAc,oBAYlC5G,EAAQ6G,oBAAsB,SAASC,GACrC,IAAIC,EAAyB,mBAAXD,GAAyBA,EAAOH,YAClD,QAAOI,IACHA,IAAShD,GAG2B,uBAAnCgD,EAAKH,aAAeG,EAAKC,QAIhChH,EAAQiH,KAAO,SAASH,GAUtB,OATI7F,OAAOiG,eACTjG,OAAOiG,eAAeJ,EAAQ9C,IAE9B8C,EAAOK,UAAYnD,EACbrC,KAAqBmF,IACzBA,EAAOnF,GAAqB,sBAGhCmF,EAAO5F,UAAYD,OAAOoB,OAAOiC,GAC1BwC,GAOT9G,EAAQoH,MAAQ,SAASzE,GACvB,MAAO,CAAEsC,QAAStC,IAsEpB4B,EAAsBE,EAAcvD,WACpCuD,EAAcvD,UAAUO,GAAuB,WAC7C,OAAOlB,MAETP,EAAQyE,cAAgBA,EAKxBzE,EAAQqH,MAAQ,SAASvF,EAASC,EAASC,EAAMC,GAC/C,IAAIqF,EAAO,IAAI7C,EACb5C,EAAKC,EAASC,EAASC,EAAMC,IAG/B,OAAOjC,EAAQ6G,oBAAoB9E,GAC/BuF,EACAA,EAAK7B,OAAOP,MAAK,SAASF,GACxB,OAAOA,EAAOxB,KAAOwB,EAAOvB,MAAQ6D,EAAK7B,WAuKjDlB,EAAsBD,GAEtBA,EAAG3C,GAAqB,YAOxB2C,EAAG/C,GAAkB,WACnB,OAAOhB,MAGT+D,EAAGzD,SAAW,WACZ,MAAO,sBAkCTb,EAAQuH,KAAO,SAASC,GACtB,IAAID,EAAO,GACX,IAAK,IAAIE,KAAOD,EACdD,EAAKpB,KAAKsB,GAMZ,OAJAF,EAAKG,UAIE,SAASjC,IACd,KAAO8B,EAAKtI,QAAQ,CAClB,IAAIwI,EAAMF,EAAKI,MACf,GAAIF,KAAOD,EAGT,OAFA/B,EAAKhC,MAAQgE,EACbhC,EAAKjC,MAAO,EACLiC,EAQX,OADAA,EAAKjC,MAAO,EACLiC,IAsCXzF,EAAQqE,OAASA,EAMjB9B,EAAQrB,UAAY,CAClByF,YAAapE,EAEb+D,MAAO,SAASsB,GAcd,GAbArH,KAAKsH,KAAO,EACZtH,KAAKkF,KAAO,EAGZlF,KAAK0C,KAAO1C,KAAK2C,WA9ejBmC,EA+eA9E,KAAKiD,MAAO,EACZjD,KAAKsC,SAAW,KAEhBtC,KAAKmC,OAAS,OACdnC,KAAKoC,SAnfL0C,EAqfA9E,KAAK2F,WAAW1B,QAAQ4B,IAEnBwB,EACH,IAAK,IAAIZ,KAAQzG,KAEQ,MAAnByG,EAAKc,OAAO,IACZ3G,EAAO0C,KAAKtD,KAAMyG,KACjBP,OAAOO,EAAKlG,MAAM,MACrBP,KAAKyG,QA7fX3B,IAmgBF0C,KAAM,WACJxH,KAAKiD,MAAO,EAEZ,IACIwE,EADYzH,KAAK2F,WAAW,GACLG,WAC3B,GAAwB,UAApB2B,EAAWzE,KACb,MAAMyE,EAAWrF,IAGnB,OAAOpC,KAAK0H,MAGd9E,kBAAmB,SAAS+E,GAC1B,GAAI3H,KAAKiD,KACP,MAAM0E,EAGR,IAAI5F,EAAU/B,KACd,SAAS4H,EAAOC,EAAKC,GAYnB,OAXAhF,EAAOE,KAAO,QACdF,EAAOV,IAAMuF,EACb5F,EAAQmD,KAAO2C,EAEXC,IAGF/F,EAAQI,OAAS,OACjBJ,EAAQK,SA9hBZ0C,KAiiBYgD,EAGZ,IAAK,IAAI3B,EAAInG,KAAK2F,WAAWjH,OAAS,EAAGyH,GAAK,IAAKA,EAAG,CACpD,IAAIb,EAAQtF,KAAK2F,WAAWQ,GACxBrD,EAASwC,EAAMQ,WAEnB,GAAqB,SAAjBR,EAAMC,OAIR,OAAOqC,EAAO,OAGhB,GAAItC,EAAMC,QAAUvF,KAAKsH,KAAM,CAC7B,IAAIS,EAAWnH,EAAO0C,KAAKgC,EAAO,YAC9B0C,EAAapH,EAAO0C,KAAKgC,EAAO,cAEpC,GAAIyC,GAAYC,EAAY,CAC1B,GAAIhI,KAAKsH,KAAOhC,EAAME,SACpB,OAAOoC,EAAOtC,EAAME,UAAU,GACzB,GAAIxF,KAAKsH,KAAOhC,EAAMG,WAC3B,OAAOmC,EAAOtC,EAAMG,iBAGjB,GAAIsC,GACT,GAAI/H,KAAKsH,KAAOhC,EAAME,SACpB,OAAOoC,EAAOtC,EAAME,UAAU,OAG3B,KAAIwC,EAMT,MAAM,IAAIrJ,MAAM,0CALhB,GAAIqB,KAAKsH,KAAOhC,EAAMG,WACpB,OAAOmC,EAAOtC,EAAMG,gBAU9B5C,OAAQ,SAASG,EAAMZ,GACrB,IAAK,IAAI+D,EAAInG,KAAK2F,WAAWjH,OAAS,EAAGyH,GAAK,IAAKA,EAAG,CACpD,IAAIb,EAAQtF,KAAK2F,WAAWQ,GAC5B,GAAIb,EAAMC,QAAUvF,KAAKsH,MACrB1G,EAAO0C,KAAKgC,EAAO,eACnBtF,KAAKsH,KAAOhC,EAAMG,WAAY,CAChC,IAAIwC,EAAe3C,EACnB,OAIA2C,IACU,UAATjF,GACS,aAATA,IACDiF,EAAa1C,QAAUnD,GACvBA,GAAO6F,EAAaxC,aAGtBwC,EAAe,MAGjB,IAAInF,EAASmF,EAAeA,EAAanC,WAAa,GAItD,OAHAhD,EAAOE,KAAOA,EACdF,EAAOV,IAAMA,EAET6F,GACFjI,KAAKmC,OAAS,OACdnC,KAAKkF,KAAO+C,EAAaxC,WAClBhD,GAGFzC,KAAKkI,SAASpF,IAGvBoF,SAAU,SAASpF,EAAQ4C,GACzB,GAAoB,UAAhB5C,EAAOE,KACT,MAAMF,EAAOV,IAcf,MAXoB,UAAhBU,EAAOE,MACS,aAAhBF,EAAOE,KACThD,KAAKkF,KAAOpC,EAAOV,IACM,WAAhBU,EAAOE,MAChBhD,KAAK0H,KAAO1H,KAAKoC,IAAMU,EAAOV,IAC9BpC,KAAKmC,OAAS,SACdnC,KAAKkF,KAAO,OACa,WAAhBpC,EAAOE,MAAqB0C,IACrC1F,KAAKkF,KAAOQ,GAGPjD,GAGT0F,OAAQ,SAAS1C,GACf,IAAK,IAAIU,EAAInG,KAAK2F,WAAWjH,OAAS,EAAGyH,GAAK,IAAKA,EAAG,CACpD,IAAIb,EAAQtF,KAAK2F,WAAWQ,GAC5B,GAAIb,EAAMG,aAAeA,EAGvB,OAFAzF,KAAKkI,SAAS5C,EAAMQ,WAAYR,EAAMI,UACtCG,EAAcP,GACP7C,IAKb,MAAS,SAAS8C,GAChB,IAAK,IAAIY,EAAInG,KAAK2F,WAAWjH,OAAS,EAAGyH,GAAK,IAAKA,EAAG,CACpD,IAAIb,EAAQtF,KAAK2F,WAAWQ,GAC5B,GAAIb,EAAMC,SAAWA,EAAQ,CAC3B,IAAIzC,EAASwC,EAAMQ,WACnB,GAAoB,UAAhBhD,EAAOE,KAAkB,CAC3B,IAAIoF,EAAStF,EAAOV,IACpByD,EAAcP,GAEhB,OAAO8C,GAMX,MAAM,IAAIzJ,MAAM,0BAGlB0J,cAAe,SAASrC,EAAUf,EAAYE,GAa5C,OAZAnF,KAAKsC,SAAW,CACdrB,SAAU6C,EAAOkC,GACjBf,WAAYA,EACZE,QAASA,GAGS,SAAhBnF,KAAKmC,SAGPnC,KAAKoC,SAvqBP0C,GA0qBOrC,IAQJhD,EAvrBK,CA8rBiBQ,EAAOR,SAGtC,IACE6I,mBAAqB9H,EACrB,MAAO+H,GAUPC,SAAS,IAAK,yBAAdA,CAAwChI,K,oBCptB1C,MAAMiI,EAAY,EAAQ,MACpB,IAAE7I,GAAQ,EAAQ,KAClB8I,EAAQ,EAAQ,KAChBC,EAAkB,EAAQ,KAC1BC,EAAe,EAAQ,MACvB,eACJC,EAAc,YACdC,EAAW,gBACXC,EAAe,UACfC,EAAS,KACTC,EAAI,UACJC,EAAS,GACTC,GACE,EAAQ,KAEZ,IAAIC,EAAgB,EAEpBnJ,EAAOR,QAAU,CAAC4J,EAAW,MAC3B,MAAMC,EAAKZ,EAAM,SAAUU,IACrB,OACJG,EAAM,SACNC,KACGC,GACDb,EAAa,IACZC,KACAQ,IAECK,EAAW,GACXC,EAAU,GAChB,IAAIC,EAASd,EAAYW,GAEzBL,GAAiB,EAEjB,MAAMS,EAAa,CAACC,EAAQC,KAC1BL,EAASI,GAAUC,GAGfC,EAAY,CAACF,EAAQG,KACzBN,EAAQG,GAAUG,GAGdC,EAAW,EAAGZ,GAAIa,EAAOL,SAAQM,aAAc,IAC/C/F,QAAQ,CAACC,EAASC,KACpB3E,EAAI,IAAI0J,aAAca,aAAiBL,KACvCD,EAAWC,EAAQxF,GACnB0F,EAAUF,EAAQvF,GAClB0E,EAAKW,EAAQ,CACXS,SAAUf,EACVa,QACAL,SACAM,cAWAE,EAAS,CAACC,EAAUJ,IACxBD,EAASzB,EAAU,CACjBa,GAAIa,EAAOL,OAAQ,SAAUM,QAAS,CAAEG,eAatCC,EAAY1D,MAAO2D,EAAMC,WACvBJ,GAAO,SACPnB,EAAGwB,UAAUF,EAAMC,SACnBJ,GAAO,GACN,CACLG,KAAM,SAASA,MAqBbG,EAAM,CAAC/K,EAAMgL,EAAO,GAAIV,IAC5BD,EAASzB,EAAU,CACjBa,GAAIa,EAAOL,OAAQ,MAAOM,QAAS,CAAEvK,OAAM4J,QAASoB,MAwExD,OAxBA7B,EAAUY,EAAQ,EAChBS,WAAUF,QAAOW,SAAQhB,SAAQiB,WAEjC,GAAe,YAAXD,EAAsB,CACxBlL,EAAI,IAAIyK,gBAAuBF,KAC/B,IAAIa,EAAID,EACR,GAAe,OAAXjB,EAAiB,CACnB,MAAM,OAAE3H,EAAQ4I,KAAME,GAAUF,EAE9BC,EADa,aAAX7I,EACE+I,WAAWC,KAAK,IAAKF,EAAOvM,OAAQgC,OAAOsG,KAAKiE,GAAOvM,SAEvDuM,EAGRvB,EAASI,GAAQ,CAAEK,QAAOY,KAAMC,QAC3B,IAAe,WAAXF,EAET,MADAnB,EAAQG,GAAQiB,GACVpM,MAAMoM,GACQ,aAAXD,IACTnC,EAAgBoC,EAAMvB,GACtBD,EAAOwB,OAIJ,CACLzB,KACAM,SACAC,aACAG,YACAoB,KA9HYjB,GACZD,EAASzB,EAAU,CACjBa,GAAIa,EAAOL,OAAQ,OAAQM,QAAS,CAAEX,cA6HxCa,SACAe,MApHYvE,MAAO2D,EAAMM,WACnBT,UACAnB,EAAGwB,UAAUF,QAAYvB,EAAU6B,UACnCT,GAAO,GACN,CACLG,KAAM,SAASA,MAgHjBD,YACAc,KApGWxE,MAAO2D,EAAMc,GAAM,KAC9B,MAAMR,QAAa5B,EAAGqC,SAASf,GAI/B,OAHIc,SACIpC,EAAGsC,WAAWhB,GAEf,CACLM,SA+FFW,OA3Fa5E,MAAO2D,UACdtB,EAAGsC,WAAWhB,GACb,CACLA,KAAM,SAASA,MAyFjBG,MACAe,UAhFgB,CAACC,EAAOC,EAAQhB,EAAO,GAAIU,GAAM,EAAMpB,IACvDS,EACE,YAAYgB,KAASf,KAAQgB,IAC7B,CAAED,QAAOC,SAAQN,OACjBpB,GA6EF2B,KAzEW,CAACF,EAAOC,EAAQV,EAAMY,EAAIlB,EAAO,GAAIU,GAAM,EAAMpB,IAC5DS,EACE,YAAYgB,SAAaT,SAAYY,KAAMlB,KAAQgB,IACnD,CAAED,QAAOC,SAAQN,OACjBpB,GAsEF6B,cAlEoBlF,MAAO8E,EAAOC,EAAQhB,EAAO,GAAIU,GAAM,EAAMpB,KACjE,MAAMO,EAAOkB,EAAMK,OAAO,CAACC,EAAKzB,IAAS,GAAGyB,WAAazB,IAAQ,IAEjE,aADMD,EAAU,kBAAmBE,GAC5BE,EAAI,sDAAsDC,KAAQgB,IACvE,CAAEN,MAAKM,SAAQD,MAAO,IAAIA,EAAO,oBACjCzB,IA8DFgC,GA3DS,CAAC1B,EAAMN,IAChBD,EAASzB,EAAU,CACjBa,GAAIa,EACJL,OAAQ,KACRM,QAAS,CAAEjI,OAAQ,UAAWtC,KAAM,CAAC4K,OAwDvC2B,UApDgBtF,MAAOqD,IACR,OAAXP,UACIM,EAASzB,EAAU,CACvBa,GAAIa,EACJL,OAAQ,eAEVf,EAAgBa,GAChBA,EAAS,MAEJvF,QAAQC,c,oBCrJnB,MAAMoE,EAAQ,EAAQ,KAEtB,IAAI2D,EAAa,EAEjBpM,EAAOR,QAAU,EACf6J,GAAIgD,EACJxC,SACAM,UAAU,OAEV,IAAId,EAAKgD,EAMT,YALkB,IAAPhD,IACTA,EAAKZ,EAAM,MAAO2D,GAClBA,GAAc,GAGT,CACL/C,KACAQ,SACAM,a,kBClBJ,IAAImC,EAAW,EAEf,MAAMC,EAAUC,IACd,MAAOC,EAAGC,EAAGC,GAAKH,EAAGI,MAAM,KAC3B,OAAwB,GAAhBC,WAAWJ,GAAU,GAAuB,GAAhBI,WAAWH,GAAWG,WAAWF,IAGvE3M,EAAOR,QAAU,EAAGsN,WAAWvD,KAC7B,GAAuB,iBAAZuD,EACT,GAAIA,EAAQC,WAAW,cAAe,CACpC,MAAMP,EAAKM,EAAQF,MAAM,MAAM,GAAGA,MAAM,MAAM,GACxC7B,EAAIwB,EAAOC,IACA,IAAbF,GAAkBA,EAAWvB,KAC/BuB,EAAWvB,QAER,GAAI+B,EAAQC,WAAW,SAAU,CACtC,MAAMP,EAAKM,EAAQF,MAAM,SAAS,GAAGA,MAAM,KAAK,GAEhDrD,EAAS,CAAEyD,MADDT,EAAOC,GACKF,SACbQ,EAAQC,WAAW,WAC5BxD,EAAS,CAAEyD,MAAO,M,oBCpBxB,MACMC,EADoD,YAAxC,EAAQ,IAAR,CAA4B,QACf,EAAQ,KAAiBN,GAAKA,EAE7D3M,EAAOR,QAAWgK,IAChB,MAAMoB,EAAO,IAAKpB,GAMlB,MALA,CAAC,WAAY,cAAcxF,QAASiD,SACN,IAAjBuC,EAAQvC,KACjB2D,EAAK3D,GAAOgG,EAAWrC,EAAK3D,OAGzB2D,I,kBCVT5K,EAAOR,QAAWyH,IAChB,MAAMiG,EAAM,CACVnK,KAAyB,oBAAXoK,aAAuD,IAApBA,OAAOvO,SAA4B,UAAY,QAGlG,YAAmB,IAARqI,EACFiG,EAEFA,EAAIjG,K,oBCCb,MAAM2B,EAAiB,EAAQ,KACzBC,EAAc,EAAQ,KACtBC,EAAkB,EAAQ,KAC1BC,EAAY,EAAQ,KACpBC,EAAO,EAAQ,KACfC,EAAY,EAAQ,KACpBC,EAAK,EAAQ,KAEnBlJ,EAAOR,QAAU,CACfoJ,iBACAC,cACAC,kBACAC,YACAC,OACAC,YACAC,O,qBCxBF,oBAAmB,EAAQ,MACrB,QAAEkE,EAAO,aAAEC,GAAiB,EAAQ,KACpCzE,EAAiB,EAAQ,KAK/B5I,EAAOR,QAAU,IACZoJ,EACH0E,gBAAgC,IAAZC,GAAsD,gBAA3BA,EAAQL,IAAIM,WACvDP,EAAW,+BAA+B9M,KAAKC,SAASC,SAAS,IAAIC,MAAM,MAC3E,qCAAqC8M,uBACzCK,SAAU,mCAAmCJ,EAAa,gBAAgBK,UAAU,oBACpFC,eAAe,K,w/ECbjB3N,EAAOR,QAAU,CACf8J,OAAQ,OACRC,SAAU,S,kBCKZvJ,EAAOR,QAAU,EAAG8N,aAAYK,oBAC9B,IAAIhE,EACJ,GAAIiE,MAAQC,KAAOF,EAAe,CAEhC,MAAMG,EAAO,IAAIF,KAAK,CAAC,kBAAkBN,QAAkB,CACzDvK,KAAM,2BAER4G,EAAS,IAAIoE,OAAOF,IAAIG,gBAAgBF,SAExCnE,EAAS,IAAIoE,OAAOT,GAEtB,OAAO3D,I,kBCXT3J,EAAOR,QAAWmK,IAChBA,EAAOwC,c,kBCRTnM,EAAOR,QAAU,CAACmK,EAAQsE,KACxBtE,EAAOuE,UAAY,EAAGpD,WACpBmD,EAAQnD,M,kBCKZ9K,EAAOR,QAAUqH,MAAO8C,EAAQwE,KAC9BxE,EAAOyE,YAAYD,K,oBCRrB,MAAMlB,EAAa,EAAQ,KAsB3BjN,EAAOR,QAAUqH,MAAOmE,IACtB,IAAIF,EAAOE,EACX,QAAqB,IAAVA,EACT,MAAO,YAGT,GAAqB,iBAAVA,EAET,GAAI,yCAAyCqD,KAAKrD,GAChDF,EAAOwD,KAAKtD,EAAM4B,MAAM,KAAK,IAC1BA,MAAM,IACN2B,IAAKC,GAAMA,EAAEC,WAAW,QACtB,CACL,MAAM3E,QAAY4E,MAAMzB,EAAWjC,IACnCF,QAAahB,EAAI6E,mBAEV3D,aAAiB4D,MAAQ5D,aAAiB4C,QACnD9C,QA9BwBgD,EA8BQ9C,EA9BC,IAC/B5G,QAAQ,CAACC,EAASC,KACpB,MAAMuK,EAAa,IAAIC,WACvBD,EAAWE,OAAS,KAClB1K,EAAQwK,EAAWrK,SAErBqK,EAAWG,QAAU,EAAGC,QAAUrK,OAASsK,aACzC5K,EAAO5F,MAAM,gCAAgCwQ,OAE/CL,EAAWM,kBAAkBrB,OATN,IAACA,EAiC1B,OAAO,IAAI7C,WAAWH,K,oBC1CxB,MAAM,OAAEsE,GAAW,EAAQ,KAErBC,EAAQ,IAAMD,EAAO,QAAS,IAE9BE,EAAoBzI,MAAO0I,IAC/B,MAAMC,QAAcD,EAAGE,IAAI,YAAa,gBAExC,MAAO,CAAEC,QADOjP,OAAOsG,KAAKyI,GAAOG,OAAQC,IAAO,CAAC,OAAQ,aAAaC,SAASD,IAAIzI,MACnE2I,KAAMN,EAAMM,OAGhC9P,EAAOR,QAAU,CACf+L,SAAU1E,MAAO2D,IACf,MAAM+E,QAAWF,KACX,QAAEK,SAAkBJ,EAAkBC,GAC5C,aAAcA,EAAGE,IAAI,YAAa,SAASjF,MAASkF,IAEtDhF,UAAW7D,MAAO2D,EAAMM,KACtB,MAAMyE,QAAWF,KACX,QAAEK,EAAO,KAAEI,SAAeR,EAAkBC,SAC5CA,EAAGQ,IACP,YACA,CACE,CAACL,GAAU5E,EACXgF,OACAE,UAAW,IAAIC,MAEjB,SAASzF,MAGbgB,WAAY3E,MAAO2D,IACjB,MAAM+E,QAAWF,UACXE,EAAGW,OAAO,YAAa,SAAS1F,Q,oMC7B1C,IAAI2F,EACAC,EAqBJ,MAAMC,EAAmB,IAAIC,QACvBC,EAAqB,IAAID,QACzBE,EAA2B,IAAIF,QAC/BG,EAAiB,IAAIH,QACrBI,EAAwB,IAAIJ,QA0DlC,IAAIK,EAAgB,CAChB,IAAI1B,EAAQ2B,EAAMC,GACd,GAAI5B,aAAkB6B,eAAgB,CAElC,GAAa,SAATF,EACA,OAAOL,EAAmBd,IAAIR,GAElC,GAAa,qBAAT2B,EACA,OAAO3B,EAAO8B,kBAAoBP,EAAyBf,IAAIR,GAGnE,GAAa,UAAT2B,EACA,OAAOC,EAASE,iBAAiB,QAC3BlM,EACAgM,EAASG,YAAYH,EAASE,iBAAiB,IAI7D,OAAO1P,EAAK4N,EAAO2B,KAEvBK,IAAG,CAAChC,EAAQ2B,IACJ3B,aAAkB6B,iBACR,SAATF,GAA4B,UAATA,IAGjBA,KAAQ3B,GAMvB,SAASiC,EAAaC,GAIlB,OAAIA,IAASC,YAAY1Q,UAAU2Q,aAC7B,qBAAsBP,eAAepQ,WAzGnC0P,IACHA,EAAuB,CACpBkB,UAAU5Q,UAAU6Q,QACpBD,UAAU5Q,UAAU8Q,SACpBF,UAAU5Q,UAAU+Q,sBAiHE5B,SAASsB,GAC5B,YAAavR,GAIhB,OADAuR,EAAKrR,MAAM4R,EAAO3R,MAAOH,GAClByB,EAAKgP,EAAiBZ,IAAI1P,QAGlC,YAAaH,GAGhB,OAAOyB,EAAK8P,EAAKrR,MAAM4R,EAAO3R,MAAOH,KAtB9B,SAAU+R,KAAe/R,GAC5B,MAAMgS,EAAKT,EAAK9N,KAAKqO,EAAO3R,MAAO4R,KAAe/R,GAElD,OADA4Q,EAAyBqB,IAAID,EAAID,EAAWG,KAAOH,EAAWG,OAAS,CAACH,IACjEtQ,EAAKuQ,IAsBxB,SAASG,EAAuB9O,GAC5B,MAAqB,mBAAVA,EACAiO,EAAajO,IAGpBA,aAAiB6N,gBA5FzB,SAAwCc,GAEpC,GAAIrB,EAAmBU,IAAIW,GACvB,OACJ,MAAM5O,EAAO,IAAIoB,QAAQ,CAACC,EAASC,KAC/B,MAAM0N,EAAW,KACbJ,EAAGK,oBAAoB,WAAYhK,GACnC2J,EAAGK,oBAAoB,QAASrN,GAChCgN,EAAGK,oBAAoB,QAASrN,IAE9BqD,EAAW,KACb5D,IACA2N,KAEEpN,EAAQ,KACVN,EAAOsN,EAAGhN,OACVoN,KAEJJ,EAAGM,iBAAiB,WAAYjK,GAChC2J,EAAGM,iBAAiB,QAAStN,GAC7BgN,EAAGM,iBAAiB,QAAStN,KAGjC2L,EAAmBsB,IAAID,EAAI5O,GAsEvBmP,CAA+BlP,GA1JhB+D,EA2JD/D,GArJVkN,IACHA,EAAoB,CACjBiB,YACAgB,eACAC,SACAf,UACAR,kBAZiDwB,KAAK9D,GAAKxH,aAAkBwH,GA4J1E,IAAI+D,MAAMtP,EAAO0N,GAErB1N,GA9JW,IAAC+D,EAgKvB,SAAS3F,EAAK4B,GAGV,GAAIA,aAAiBuP,WACjB,OAvIR,SAA0BC,GACtB,MAAMC,EAAU,IAAItO,QAAQ,CAACC,EAASC,KAClC,MAAM0N,EAAW,KACbS,EAAQR,oBAAoB,UAAWU,GACvCF,EAAQR,oBAAoB,QAASrN,IAEnC+N,EAAU,KACZtO,EAAQhD,EAAKoR,EAAQjO,SACrBwN,KAEEpN,EAAQ,KACVN,EAAOmO,EAAQ7N,OACfoN,KAEJS,EAAQP,iBAAiB,UAAWS,GACpCF,EAAQP,iBAAiB,QAAStN,KAetC,OAbA8N,EACKhO,KAAKzB,IAGFA,aAAiBqO,WACjBjB,EAAiBwB,IAAI5O,EAAOwP,KAI/BG,MAAM,QAGXlC,EAAsBmB,IAAIa,EAASD,GAC5BC,EAyGIG,CAAiB5P,GAG5B,GAAIwN,EAAeQ,IAAIhO,GACnB,OAAOwN,EAAehB,IAAIxM,GAC9B,MAAM6P,EAAWf,EAAuB9O,GAOxC,OAJI6P,IAAa7P,IACbwN,EAAeoB,IAAI5O,EAAO6P,GAC1BpC,EAAsBmB,IAAIiB,EAAU7P,IAEjC6P,EAEX,MAAMpB,EAAUzO,GAAUyN,EAAsBjB,IAAIxM,GCxKpD,SAASmM,EAAO5I,EAAM4G,GAAS,QAAE2F,EAAO,QAAEC,EAAO,SAAEC,GAAa,IAC5D,MAAMR,EAAUS,UAAUC,KAAK3M,EAAM4G,GAC/BgG,EAAc/R,EAAKoR,GAWzB,OAVIO,GACAP,EAAQP,iBAAiB,gBAAiBmB,IACtCL,EAAQ3R,EAAKoR,EAAQjO,QAAS6O,EAAMC,WAAYD,EAAME,WAAYlS,EAAKoR,EAAQpB,gBAGnF0B,GACAN,EAAQP,iBAAiB,UAAW,IAAMa,KAC1CE,GACAG,EAAY1O,KAAK6K,GAAMA,EAAG2C,iBAAiB,gBAAiBe,IAAWL,MAAM,QAE1EQ,EAOX,SAASI,EAAShN,GAAM,QAAEuM,GAAY,IAClC,MAAMN,EAAUS,UAAUO,eAAejN,GAGzC,OAFIuM,GACAN,EAAQP,iBAAiB,UAAW,IAAMa,KACvC1R,EAAKoR,GAAS/N,KAAK,QAG9B,MAAMgP,EAAc,CAAC,MAAO,SAAU,SAAU,aAAc,SACxDC,EAAe,CAAC,MAAO,MAAO,SAAU,SACxCC,EAAgB,IAAIC,IAC1B,SAASC,EAAU7E,EAAQ2B,GACvB,KAAM3B,aAAkBmC,cAClBR,KAAQ3B,GACM,iBAAT2B,EACP,OAEJ,GAAIgD,EAAcnE,IAAImB,GAClB,OAAOgD,EAAcnE,IAAImB,GAC7B,MAAMmD,EAAiBnD,EAAKoD,QAAQ,aAAc,IAC5CC,EAAWrD,IAASmD,EACpBG,EAAUP,EAAa9D,SAASkE,GACtC,KAEEA,KAAmBE,EAAW5B,SAAWD,gBAAgB1R,aACrDwT,IAAWR,EAAY7D,SAASkE,GAClC,OAEJ,MAAM7R,EAAS2E,eAAgBsN,KAAcvU,GAEzC,MAAMgS,EAAK7R,KAAKsR,YAAY8C,EAAWD,EAAU,YAAc,YAC/D,IAAIjF,EAAS2C,EAAGwC,MACZH,IACAhF,EAASA,EAAO5P,MAAMO,EAAKyU,UAC/B,MAAMC,EAAYrF,EAAO8E,MAAmBnU,GAG5C,OAFIsU,SACMtC,EAAG5O,KACNsR,GAGX,OADAV,EAAc/B,IAAIjB,EAAM1O,GACjBA,ED8CPyO,EC5CK4D,KAAY,CACjB9E,IAAK,CAACR,EAAQ2B,EAAMC,IAAaiD,EAAU7E,EAAQ2B,IAAS2D,EAAS9E,IAAIR,EAAQ2B,EAAMC,GACvFI,IAAK,CAAChC,EAAQ2B,MAAWkD,EAAU7E,EAAQ2B,IAAS2D,EAAStD,IAAIhC,EAAQ2B,KD0CzD4D,CAAS7D,I,oBEnH7B,EAAQ,KACR,MAAM,QAAEpR,EAAO,WAAEE,GAAe,EAAQ,KAClCgV,EAAe,EAAQ,KAE7BzU,EAAOR,QAAU,CACfD,UACAE,aACAgV","file":"vendors~ffmpeg-1.js","sourcesContent":["// Copyright 2014 Simon Lydell\r\n// X11 (“MIT”) Licensed. (See LICENSE.)\r\n\r\nvoid (function(root, factory) {\r\n  if (typeof define === \"function\" && define.amd) {\r\n    define(factory)\r\n  } else if (typeof exports === \"object\") {\r\n    module.exports = factory()\r\n  } else {\r\n    root.resolveUrl = factory()\r\n  }\r\n}(this, function() {\r\n\r\n  function resolveUrl(/* ...urls */) {\r\n    var numUrls = arguments.length\r\n\r\n    if (numUrls === 0) {\r\n      throw new Error(\"resolveUrl requires at least one argument; got none.\")\r\n    }\r\n\r\n    var base = document.createElement(\"base\")\r\n    base.href = arguments[0]\r\n\r\n    if (numUrls === 1) {\r\n      return base.href\r\n    }\r\n\r\n    var head = document.getElementsByTagName(\"head\")[0]\r\n    head.insertBefore(base, head.firstChild)\r\n\r\n    var a = document.createElement(\"a\")\r\n    var resolved\r\n\r\n    for (var index = 1; index < numUrls; index++) {\r\n      a.href = arguments[index]\r\n      resolved = a.href\r\n      base.href = resolved\r\n    }\r\n\r\n    head.removeChild(base)\r\n\r\n    return resolved\r\n  }\r\n\r\n  return resolveUrl\r\n\r\n}));\r\n","let logging = false;\n\nexports.logging = logging;\n\nexports.setLogging = (_logging) => {\n  logging = _logging;\n};\n\nexports.log = (...args) => (logging ? console.log.apply(this, args) : null);\n","module.exports = (prefix, cnt) => (\n  `${prefix}-${cnt}-${Math.random().toString(16).slice(3, 8)}`\n);\n","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar runtime = (function (exports) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  typeof module === \"object\" ? module.exports : {}\n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n}\n","const createJob = require('./createJob');\nconst { log } = require('./utils/log');\nconst getId = require('./utils/getId');\nconst extractProgress = require('./utils/extractProgress');\nconst resolvePaths = require('./utils/resolvePaths');\nconst {\n  defaultOptions,\n  spawnWorker,\n  terminateWorker,\n  onMessage,\n  send,\n  fetchFile,\n  fs,\n} = require('./worker/node');\n\nlet workerCounter = 0;\n\nmodule.exports = (_options = {}) => {\n  const id = getId('Worker', workerCounter);\n  const {\n    logger,\n    progress,\n    ...options\n  } = resolvePaths({\n    ...defaultOptions,\n    ..._options,\n  });\n  const resolves = {};\n  const rejects = {};\n  let worker = spawnWorker(options);\n\n  workerCounter += 1;\n\n  const setResolve = (action, res) => {\n    resolves[action] = res;\n  };\n\n  const setReject = (action, rej) => {\n    rejects[action] = rej;\n  };\n\n  const startJob = ({ id: jobId, action, payload }) => (\n    new Promise((resolve, reject) => {\n      log(`[${id}]: Start ${jobId}, action=${action}`);\n      setResolve(action, resolve);\n      setReject(action, reject);\n      send(worker, {\n        workerId: id,\n        jobId,\n        action,\n        payload,\n      });\n    })\n  );\n\n  const load = (jobId) => (\n    startJob(createJob({\n      id: jobId, action: 'load', payload: { options },\n    }))\n  );\n\n  const syncfs = (populate, jobId) => (\n    startJob(createJob({\n      id: jobId, action: 'syncfs', payload: { populate },\n    }))\n  );\n\n  const write = async (path, data) => {\n    await syncfs();\n    await fs.writeFile(path, await fetchFile(data));\n    await syncfs(true);\n    return {\n      path: `/data/${path}`,\n    };\n  };\n\n  const writeText = async (path, text) => {\n    await syncfs(true);\n    await fs.writeFile(path, text);\n    await syncfs(true);\n    return {\n      path: `/data/${path}`,\n    };\n  };\n\n  const read = async (path, del = true) => {\n    const data = await fs.readFile(path);\n    if (del) {\n      await fs.deleteFile(path);\n    }\n    return {\n      data,\n    };\n  };\n\n  const remove = async (path) => {\n    await fs.deleteFile(path);\n    return {\n      path: `/data/${path}`,\n    };\n  };\n\n  const run = (args, opts = {}, jobId) => (\n    startJob(createJob({\n      id: jobId, action: 'run', payload: { args, options: opts },\n    }))\n  );\n\n  const transcode = (input, output, opts = '', del = true, jobId) => (\n    run(\n      `-i /data/${input} ${opts} ${output}`,\n      { input, output, del },\n      jobId,\n    )\n  );\n\n  const trim = (input, output, from, to, opts = '', del = true, jobId) => (\n    run(\n      `-i /data/${input} -ss ${from} -to ${to} ${opts} ${output}`,\n      { input, output, del },\n      jobId,\n    )\n  );\n\n  const concatDemuxer = async (input, output, opts = '', del = true, jobId) => {\n    const text = input.reduce((acc, path) => `${acc}\\nfile ${path}`, '');\n    await writeText('concat_list.txt', text);\n    return run(`-f concat -safe 0 -i /data/concat_list.txt -c copy ${opts} ${output}`,\n      { del, output, input: [...input, 'concat_list.txt'] },\n      jobId);\n  };\n\n  const ls = (path, jobId) => (\n    startJob(createJob({\n      id: jobId,\n      action: 'FS',\n      payload: { method: 'readdir', args: [path] },\n    }))\n  );\n\n  const terminate = async (jobId) => {\n    if (worker !== null) {\n      await startJob(createJob({\n        id: jobId,\n        action: 'terminate',\n      }));\n      terminateWorker(worker);\n      worker = null;\n    }\n    return Promise.resolve();\n  };\n\n  onMessage(worker, ({\n    workerId, jobId, status, action, data,\n  }) => {\n    if (status === 'resolve') {\n      log(`[${workerId}]: Complete ${jobId}`);\n      let d = data;\n      if (action === 'FS') {\n        const { method, data: _data } = data;\n        if (method === 'readFile') {\n          d = Uint8Array.from({ ..._data, length: Object.keys(_data).length });\n        } else {\n          d = _data;\n        }\n      }\n      resolves[action]({ jobId, data: d });\n    } else if (status === 'reject') {\n      rejects[action](data);\n      throw Error(data);\n    } else if (status === 'progress') {\n      extractProgress(data, progress);\n      logger(data);\n    }\n  });\n\n  return {\n    id,\n    worker,\n    setResolve,\n    setReject,\n    load,\n    syncfs,\n    write,\n    writeText,\n    read,\n    remove,\n    run,\n    transcode,\n    trim,\n    concatDemuxer,\n    ls,\n    terminate,\n  };\n};\n","const getId = require('./utils/getId');\n\nlet jobCounter = 0;\n\nmodule.exports = ({\n  id: _id,\n  action,\n  payload = {},\n}) => {\n  let id = _id;\n  if (typeof id === 'undefined') {\n    id = getId('Job', jobCounter);\n    jobCounter += 1;\n  }\n\n  return {\n    id,\n    action,\n    payload,\n  };\n};\n","let duration = 0;\n\nconst ts2sec = (ts) => {\n  const [h, m, s] = ts.split(':');\n  return (parseFloat(h) * 60 * 60) + (parseFloat(m) * 60) + parseFloat(s);\n};\n\nmodule.exports = ({ message }, progress) => {\n  if (typeof message === 'string') {\n    if (message.startsWith('  Duration')) {\n      const ts = message.split(', ')[0].split(': ')[1];\n      const d = ts2sec(ts);\n      if (duration === 0 || duration > d) {\n        duration = d;\n      }\n    } else if (message.startsWith('frame')) {\n      const ts = message.split('time=')[1].split(' ')[0];\n      const t = ts2sec(ts);\n      progress({ ratio: t / duration });\n    } else if (message.startsWith('video:')) {\n      progress({ ratio: 1 });\n    }\n  }\n};\n","const isBrowser = require('./getEnvironment')('type') === 'browser';\nconst resolveURL = isBrowser ? require('resolve-url') : s => s; // eslint-disable-line\n\nmodule.exports = (options) => {\n  const opts = { ...options };\n  ['corePath', 'workerPath'].forEach((key) => {\n    if (typeof options[key] !== 'undefined') {\n      opts[key] = resolveURL(opts[key]);\n    }\n  });\n  return opts;\n};\n","module.exports = (key) => {\n  const env = {\n    type: (typeof window !== 'undefined') && (typeof window.document !== 'undefined') ? 'browser' : 'node',\n  };\n\n  if (typeof key === 'undefined') {\n    return env;\n  }\n  return env[key];\n};\n","/**\n *\n * Tesseract Worker adapter for browser\n *\n * @fileoverview Tesseract Worker adapter for browser\n * @author Kevin Kwok <antimatter15@gmail.com>\n * @author Guillermo Webster <gui@mit.edu>\n * @author Jerome Wu <jeromewus@gmail.com>\n */\nconst defaultOptions = require('./defaultOptions');\nconst spawnWorker = require('./spawnWorker');\nconst terminateWorker = require('./terminateWorker');\nconst onMessage = require('./onMessage');\nconst send = require('./send');\nconst fetchFile = require('./fetchFile');\nconst fs = require('./fs');\n\nmodule.exports = {\n  defaultOptions,\n  spawnWorker,\n  terminateWorker,\n  onMessage,\n  send,\n  fetchFile,\n  fs,\n};\n","const resolveURL = require('resolve-url');\nconst { version, dependencies } = require('../../../package.json');\nconst defaultOptions = require('../../constants/defaultOptions');\n\n/*\n * Default options for browser worker\n */\nmodule.exports = {\n  ...defaultOptions,\n  workerPath: (typeof process !== 'undefined' && process.env.FFMPEG_ENV === 'development')\n    ? resolveURL(`/dist/worker.dev.js?nocache=${Math.random().toString(36).slice(3)}`)\n    : `https://unpkg.com/@ffmpeg/ffmpeg@v${version}/dist/worker.min.js`,\n  corePath: `https://unpkg.com/@ffmpeg/core@v${dependencies['@ffmpeg/core'].substring(1)}/ffmpeg-core.js`,\n  workerBlobURL: true,\n};\n","module.exports = {\n  logger: () => {},\n  progress: () => {},\n};\n","/**\n * spawnWorker\n *\n * @name spawnWorker\n * @function create a new Worker in browser\n * @access public\n */\nmodule.exports = ({ workerPath, workerBlobURL }) => {\n  let worker;\n  if (Blob && URL && workerBlobURL) {\n    /* Use Blob to load cross domain worker script */\n    const blob = new Blob([`importScripts(\"${workerPath}\");`], {\n      type: 'application/javascript',\n    });\n    worker = new Worker(URL.createObjectURL(blob));\n  } else {\n    worker = new Worker(workerPath);\n  }\n  return worker;\n};\n","/**\n * terminateWorker\n *\n * @name terminateWorker\n * @function terminate worker\n * @access public\n */\nmodule.exports = (worker) => {\n  worker.terminate();\n};\n","module.exports = (worker, handler) => {\n  worker.onmessage = ({ data }) => { // eslint-disable-line\n    handler(data);\n  };\n};\n","/**\n * send\n *\n * @name send\n * @function send packet to worker and create a job\n * @access public\n */\nmodule.exports = async (worker, packet) => {\n  worker.postMessage(packet);\n};\n","const resolveURL = require('resolve-url');\n\n/**\n * readFromBlobOrFile\n *\n * @name readFromBlobOrFile\n * @function\n * @access private\n */\nconst readFromBlobOrFile = (blob) => (\n  new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n      resolve(fileReader.result);\n    };\n    fileReader.onerror = ({ target: { error: { code } } }) => {\n      reject(Error(`File could not be read! Code=${code}`));\n    };\n    fileReader.readAsArrayBuffer(blob);\n  })\n);\n\nmodule.exports = async (_data) => {\n  let data = _data;\n  if (typeof _data === 'undefined') {\n    return 'undefined';\n  }\n\n  if (typeof _data === 'string') {\n    // Base64 _data\n    if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(_data)) {\n      data = atob(_data.split(',')[1])\n        .split('')\n        .map((c) => c.charCodeAt(0));\n    } else {\n      const res = await fetch(resolveURL(_data));\n      data = await res.arrayBuffer();\n    }\n  } else if (_data instanceof File || _data instanceof Blob) {\n    data = await readFromBlobOrFile(_data);\n  }\n\n  return new Uint8Array(data);\n};\n","const { openDB } = require('idb');\n\nconst getDB = () => openDB('/data', 21);\n\nconst getDataKeyAndMode = async (db) => {\n  const dummy = await db.get('FILE_DATA', '/data/.DUMMY');\n  const dataKey = Object.keys(dummy).filter((k) => !['mode', 'timestamp'].includes(k)).pop();\n  return { dataKey, mode: dummy.mode };\n};\n\nmodule.exports = {\n  readFile: async (path) => {\n    const db = await getDB();\n    const { dataKey } = await getDataKeyAndMode(db);\n    return (await db.get('FILE_DATA', `/data/${path}`))[dataKey];\n  },\n  writeFile: async (path, data) => {\n    const db = await getDB();\n    const { dataKey, mode } = await getDataKeyAndMode(db);\n    await db.put(\n      'FILE_DATA',\n      {\n        [dataKey]: data,\n        mode,\n        timestamp: new Date(),\n      },\n      `/data/${path}`,\n    );\n  },\n  deleteFile: async (path) => {\n    const db = await getDB();\n    await db.delete('FILE_DATA', `/data/${path}`);\n  },\n};\n","const instanceOfAny = (object, constructors) => constructors.some(c => object instanceof c);\n\nlet idbProxyableTypes;\r\nlet cursorAdvanceMethods;\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getIdbProxyableTypes() {\r\n    return (idbProxyableTypes ||\r\n        (idbProxyableTypes = [\r\n            IDBDatabase,\r\n            IDBObjectStore,\r\n            IDBIndex,\r\n            IDBCursor,\r\n            IDBTransaction,\r\n        ]));\r\n}\r\n// This is a function to prevent it throwing up in node environments.\r\nfunction getCursorAdvanceMethods() {\r\n    return (cursorAdvanceMethods ||\r\n        (cursorAdvanceMethods = [\r\n            IDBCursor.prototype.advance,\r\n            IDBCursor.prototype.continue,\r\n            IDBCursor.prototype.continuePrimaryKey,\r\n        ]));\r\n}\r\nconst cursorRequestMap = new WeakMap();\r\nconst transactionDoneMap = new WeakMap();\r\nconst transactionStoreNamesMap = new WeakMap();\r\nconst transformCache = new WeakMap();\r\nconst reverseTransformCache = new WeakMap();\r\nfunction promisifyRequest(request) {\r\n    const promise = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            request.removeEventListener('success', success);\r\n            request.removeEventListener('error', error);\r\n        };\r\n        const success = () => {\r\n            resolve(wrap(request.result));\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(request.error);\r\n            unlisten();\r\n        };\r\n        request.addEventListener('success', success);\r\n        request.addEventListener('error', error);\r\n    });\r\n    promise\r\n        .then(value => {\r\n        // Since cursoring reuses the IDBRequest (*sigh*), we cache it for later retrieval\r\n        // (see wrapFunction).\r\n        if (value instanceof IDBCursor) {\r\n            cursorRequestMap.set(value, request);\r\n        }\r\n        // Catching to avoid \"Uncaught Promise exceptions\"\r\n    })\r\n        .catch(() => { });\r\n    // This mapping exists in reverseTransformCache but doesn't doesn't exist in transformCache. This\r\n    // is because we create many promises from a single IDBRequest.\r\n    reverseTransformCache.set(promise, request);\r\n    return promise;\r\n}\r\nfunction cacheDonePromiseForTransaction(tx) {\r\n    // Early bail if we've already created a done promise for this transaction.\r\n    if (transactionDoneMap.has(tx))\r\n        return;\r\n    const done = new Promise((resolve, reject) => {\r\n        const unlisten = () => {\r\n            tx.removeEventListener('complete', complete);\r\n            tx.removeEventListener('error', error);\r\n            tx.removeEventListener('abort', error);\r\n        };\r\n        const complete = () => {\r\n            resolve();\r\n            unlisten();\r\n        };\r\n        const error = () => {\r\n            reject(tx.error);\r\n            unlisten();\r\n        };\r\n        tx.addEventListener('complete', complete);\r\n        tx.addEventListener('error', error);\r\n        tx.addEventListener('abort', error);\r\n    });\r\n    // Cache it for later retrieval.\r\n    transactionDoneMap.set(tx, done);\r\n}\r\nlet idbProxyTraps = {\r\n    get(target, prop, receiver) {\r\n        if (target instanceof IDBTransaction) {\r\n            // Special handling for transaction.done.\r\n            if (prop === 'done')\r\n                return transactionDoneMap.get(target);\r\n            // Polyfill for objectStoreNames because of Edge.\r\n            if (prop === 'objectStoreNames') {\r\n                return target.objectStoreNames || transactionStoreNamesMap.get(target);\r\n            }\r\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\r\n            if (prop === 'store') {\r\n                return receiver.objectStoreNames[1]\r\n                    ? undefined\r\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\r\n            }\r\n        }\r\n        // Else transform whatever we get back.\r\n        return wrap(target[prop]);\r\n    },\r\n    has(target, prop) {\r\n        if (target instanceof IDBTransaction &&\r\n            (prop === 'done' || prop === 'store')) {\r\n            return true;\r\n        }\r\n        return prop in target;\r\n    },\r\n};\r\nfunction addTraps(callback) {\r\n    idbProxyTraps = callback(idbProxyTraps);\r\n}\r\nfunction wrapFunction(func) {\r\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\r\n    // only create one new func per func.\r\n    // Edge doesn't support objectStoreNames (booo), so we polyfill it here.\r\n    if (func === IDBDatabase.prototype.transaction &&\r\n        !('objectStoreNames' in IDBTransaction.prototype)) {\r\n        return function (storeNames, ...args) {\r\n            const tx = func.call(unwrap(this), storeNames, ...args);\r\n            transactionStoreNamesMap.set(tx, storeNames.sort ? storeNames.sort() : [storeNames]);\r\n            return wrap(tx);\r\n        };\r\n    }\r\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\r\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\r\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\r\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\r\n    // undefined if the end of the cursor has been reached.\r\n    if (getCursorAdvanceMethods().includes(func)) {\r\n        return function (...args) {\r\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n            // the original object.\r\n            func.apply(unwrap(this), args);\r\n            return wrap(cursorRequestMap.get(this));\r\n        };\r\n    }\r\n    return function (...args) {\r\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\r\n        // the original object.\r\n        return wrap(func.apply(unwrap(this), args));\r\n    };\r\n}\r\nfunction transformCachableValue(value) {\r\n    if (typeof value === 'function')\r\n        return wrapFunction(value);\r\n    // This doesn't return, it just creates a 'done' promise for the transaction,\r\n    // which is later returned for transaction.done (see idbObjectHandler).\r\n    if (value instanceof IDBTransaction)\r\n        cacheDonePromiseForTransaction(value);\r\n    if (instanceOfAny(value, getIdbProxyableTypes()))\r\n        return new Proxy(value, idbProxyTraps);\r\n    // Return the same value back if we're not going to transform it.\r\n    return value;\r\n}\r\nfunction wrap(value) {\r\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\r\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\r\n    if (value instanceof IDBRequest)\r\n        return promisifyRequest(value);\r\n    // If we've already transformed this value before, reuse the transformed value.\r\n    // This is faster, but it also provides object equality.\r\n    if (transformCache.has(value))\r\n        return transformCache.get(value);\r\n    const newValue = transformCachableValue(value);\r\n    // Not all types are transformed.\r\n    // These may be primitive types, so they can't be WeakMap keys.\r\n    if (newValue !== value) {\r\n        transformCache.set(value, newValue);\r\n        reverseTransformCache.set(newValue, value);\r\n    }\r\n    return newValue;\r\n}\r\nconst unwrap = (value) => reverseTransformCache.get(value);\n\nexport { wrap as a, addTraps as b, instanceOfAny as c, reverseTransformCache as d, unwrap as e };\n","import { a as wrap, b as addTraps } from './chunk.js';\nexport { e as unwrap, a as wrap } from './chunk.js';\n\n/**\r\n * Open a database.\r\n *\r\n * @param name Name of the database.\r\n * @param version Schema version.\r\n * @param callbacks Additional callbacks.\r\n */\r\nfunction openDB(name, version, { blocked, upgrade, blocking } = {}) {\r\n    const request = indexedDB.open(name, version);\r\n    const openPromise = wrap(request);\r\n    if (upgrade) {\r\n        request.addEventListener('upgradeneeded', event => {\r\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction));\r\n        });\r\n    }\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    if (blocking) {\r\n        openPromise.then(db => db.addEventListener('versionchange', blocking)).catch(() => { });\r\n    }\r\n    return openPromise;\r\n}\r\n/**\r\n * Delete a database.\r\n *\r\n * @param name Name of the database.\r\n */\r\nfunction deleteDB(name, { blocked } = {}) {\r\n    const request = indexedDB.deleteDatabase(name);\r\n    if (blocked)\r\n        request.addEventListener('blocked', () => blocked());\r\n    return wrap(request).then(() => undefined);\r\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\r\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\r\nconst cachedMethods = new Map();\r\nfunction getMethod(target, prop) {\r\n    if (!(target instanceof IDBDatabase &&\r\n        !(prop in target) &&\r\n        typeof prop === 'string')) {\r\n        return;\r\n    }\r\n    if (cachedMethods.get(prop))\r\n        return cachedMethods.get(prop);\r\n    const targetFuncName = prop.replace(/FromIndex$/, '');\r\n    const useIndex = prop !== targetFuncName;\r\n    const isWrite = writeMethods.includes(targetFuncName);\r\n    if (\r\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\r\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\r\n        !(isWrite || readMethods.includes(targetFuncName))) {\r\n        return;\r\n    }\r\n    const method = async function (storeName, ...args) {\r\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\r\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\r\n        let target = tx.store;\r\n        if (useIndex)\r\n            target = target.index(args.shift());\r\n        const returnVal = target[targetFuncName](...args);\r\n        if (isWrite)\r\n            await tx.done;\r\n        return returnVal;\r\n    };\r\n    cachedMethods.set(prop, method);\r\n    return method;\r\n}\r\naddTraps(oldTraps => ({\r\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\r\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\r\n}));\n\nexport { openDB, deleteDB };\n","require('regenerator-runtime/runtime');\nconst { logging, setLogging } = require('./utils/log');\nconst createWorker = require('./createWorker');\n\nmodule.exports = {\n  logging,\n  setLogging,\n  createWorker,\n};\n"],"sourceRoot":""}